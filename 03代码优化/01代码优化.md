## V8引擎原理
    1、拿到JavaScript后 反义成 abstract Syntax tree 拿到抽象树
    2、然后 Interpreter(解释器) 给 optiomsing compiler(优化器) 然后在转为字节码
        也有可能不会优化，用户尽量按照v8优化条件来书写

    功能优化
        源码 -> 抽象语法树 -> 字节码 ByteCode -> 机器码
        编译过程会进行优化
        运行时间可能发生反优化
## V8 部分优化机制
    脚步流
        1、有可能js文件过大，它可以下载一部分后然后新开启线程解析
        2、当下载完毕了 直接合并
    字节码缓存
        当源码被翻译成了字节码，如果有大量的相同代码，则可以直接从字节码里面缓存
    懒解析
       当遇到函数定义时，可以先不解析函数中的内容，等到调用改函数的时候在解析。 
## 函数优化(v8 默认会对函数懒解析)
    1、在 heap 上也不会开辟空火箭
    2、lazy parsing 懒解析
    3、eager pasrgin 饥饿解析 即遇见函数就解析
        可以使用 Optimize.js 优化初始化加载时间优化。
    
## 对象优化
    1、以相同顺序初始化对象成员、避免隐藏类的调整
        编译器最终还是要知道具体类型
    2、实列化后避免添加新属性
    3、尽量使用 ARRAY 对象 代替 LIKE-ARRAY 对象
    4、尽量不要操作越界数组。
        有可能找不到 还要往原行链上寻找。这样子的查找开销是很大的
    5、避免本身类型转换。
       Array 类型越具体 编译器可以做到更到优化
       Array 类型越通用 编译器优化的就很少了
## HTML 优化
    1、减少 IFRAMES 使用
        如果非要使用，则可以使用延迟加载。这样子不会影响父文档加载
    2、压缩空白符，在线上环境上。
    3、避免节点深层级嵌套。
    4、避免使用 table 布局
    5、css & javascript 尽量使用外联
    6、删除元素默认属性
    使用 html-minifier 优化 一版情况下 webpack等构建工具会集成这个。
## css 优化
    1、降低 css 对渲染的阻塞
    2、降低 css 的大小
    3、利用 gpu 进行完成动画
    4、使用 contain: layout 属性进行优化
        告诉这个 盒子和外部没有关系
        这样子在重绘的时候的 可以减少影响外部变化
    5、使用 font-display 属性
        1、可以尽早显示文子
## js 的开心和如何压缩解析时间
    开销的地方
        加载、解析&编译、执行
    解决方案
        code splitting 代码拆分 按需加载
        tree shaking 代码减重
    避免长任务
    避免超过 1kb 的行间脚本
    使用 rAf 和 rIc 进行时间调度
    
